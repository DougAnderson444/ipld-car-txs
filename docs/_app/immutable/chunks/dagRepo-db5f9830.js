import{v as x,e as E,d as b,C as u,p as D,c as k,a as O,b as C,f as H,g as A,i as _,h as S,j as $,k as T,l as J,A as I,m as L,n as R,T as w}from"./index-0a678716.js";const z="dag-pb",U=112;function P(e){x(e);const t={};return e.Links&&(t.Links=e.Links.map(r=>{const a={};return r.Hash&&(a.Hash=r.Hash.bytes),r.Name!==void 0&&(a.Name=r.Name),r.Tsize!==void 0&&(a.Tsize=r.Tsize),a})),e.Data&&(t.Data=e.Data),E(t)}function M(e){const t=b(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map(a=>{const s={};try{s.Hash=u.decode(a.Hash)}catch{}if(!s.Hash)throw new Error("Invalid Hash field found in link, expected CID");return a.Name!==void 0&&(s.Name=a.Name),a.Tsize!==void 0&&(s.Tsize=a.Tsize),s})),r}const W=Object.freeze(Object.defineProperty({__proto__:null,name:z,code:U,encode:P,decode:M,prepare:D,validate:x,createNode:k,createLink:O},Symbol.toStringTag,{value:"Module"}));function h(e){return C.encode(e).slice(1)}function c(e){return C.decode(`u${e}`)}function G(e){const[t,r,a]=e;return{payload:r,signatures:[{protected:t,signature:a}],link:u.decode(c(r))}}function F(e){const t={signature:c(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=c(e.protected)),t}function q(e){const t=c(e.payload);try{u.decode(t)}catch{throw new Error("Not a valid DagJWS")}return{payload:t,signatures:e.signatures.map(F)}}function K(e){const t={signature:h(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=h(e.protected)),t}function Q(e){const t={payload:h(e.payload),signatures:e.signatures.map(K)};return t.link=u.decode(new Uint8Array(e.payload)),t}function V(e){const[t,r,a,s,d]=e,n={ciphertext:s,iv:a,protected:t,tag:d};return r&&(n.recipients=[{encrypted_key:r}]),n}function X(e){const t={};return e.encrypted_key&&(t.encrypted_key=c(e.encrypted_key)),e.header&&(t.header=e.header),t}function Y(e){const t={ciphertext:c(e.ciphertext),protected:c(e.protected),iv:c(e.iv),tag:c(e.tag)};return e.aad&&(t.aad=c(e.aad)),e.recipients&&(t.recipients=e.recipients.map(X)),e.unprotected&&(t.unprotected=e.unprotected),t}function Z(e){const t={};return e.encrypted_key&&(t.encrypted_key=h(e.encrypted_key)),e.header&&(t.header=e.header),t}function j(e){const t={ciphertext:h(e.ciphertext),protected:h(e.protected),iv:h(e.iv),tag:h(e.tag)};return e.aad&&(t.aad=h(e.aad)),e.recipients&&(t.recipients=e.recipients.map(Z)),e.unprotected&&(t.unprotected=e.unprotected),t}const ee="dag-jose",te=133;function v(e){return"payload"in e&&typeof e.payload=="string"&&"signatures"in e&&Array.isArray(e.signatures)}function re(e){return"payload"in e&&e.payload instanceof Uint8Array&&"signatures"in e&&Array.isArray(e.signatures)}function ae(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}function B(e){return"ciphertext"in e&&typeof e.ciphertext=="string"&&"iv"in e&&typeof e.iv=="string"&&"protected"in e&&typeof e.protected=="string"&&"tag"in e&&typeof e.tag=="string"}function N(e){if(typeof e=="string"){const t=e.split(".");if(t.length===3)return G(t);if(t.length===5)return V(t);throw new Error("Not a valid JOSE string")}if(v(e)||B(e))return e;throw new Error("Not a valid unencoded JOSE object")}function ne(e){typeof e=="string"&&(e=N(e));let t;if(v(e))t=q(e);else if(B(e))t=Y(e);else throw new Error("Not a valid JOSE object");return new Uint8Array(H(t))}function ie(e){let t;try{t=A(e)}catch{throw new Error("Not a valid DAG-JOSE object")}if(re(t))return Q(t);if(ae(t))return j(t);throw new Error("Not a valid DAG-JOSE object")}const se=Object.freeze(Object.defineProperty({__proto__:null,name:ee,code:te,toGeneral:N,encode:ne,decode:ie},Symbol.toStringTag,{value:"Module"})),oe=e=>Promise.reject(new Error(`No codec found for "${e}"`));class ce{constructor(t){this._codecsByName={},this._codecsByCode={},this._loadCodec=t.loadCodec||oe;for(const r of t.codecs)this.addCodec(r)}addCodec(t){if(this._codecsByName[t.name]||this._codecsByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._codecsByName[t.name]=t,this._codecsByCode[t.code]=t}removeCodec(t){delete this._codecsByName[t.name],delete this._codecsByCode[t.code]}async getCodec(t){const r=typeof t=="string"?this._codecsByName:this._codecsByCode;if(r[t])return r[t];const a=await this._loadCodec(t);return r[t]==null&&this.addCodec(a),a}listCodecs(){return Object.values(this._codecsByName)}}const de=e=>Promise.reject(new Error(`No hasher found for "${e}"`));class he{constructor(t){this._hashersByName={},this._hashersByCode={},this._loadHasher=t.loadHasher||de;for(const r of t.hashers)this.addHasher(r)}addHasher(t){if(this._hashersByName[t.name]||this._hashersByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._hashersByName[t.name]=t,this._hashersByCode[t.code]=t}removeHasher(t){delete this._hashersByName[t.name],delete this._hashersByCode[t.code]}async getHasher(t){const r=typeof t=="string"?this._hashersByName:this._hashersByCode;if(r[t])return r[t];const a=await this._loadHasher(t);return r[t]==null&&this.addHasher(a),a}listHashers(){return Object.values(this._hashersByName)}}async function*le(e){let t=0;for(;t<e.length;)yield e[t++]}const ue=async e=>{const t=[];for await(const r of e)t.push(r);return t};var fe=ue;class pe extends I{constructor({repo:t,codecs:r,options:a}){const s=Object.values(L);(a.ipld&&a.ipld.hashers?a.ipld.hashers:[]).forEach(n=>s.push(n));const d=new he({hashers:s,loadHasher:a.ipld&&a.ipld.loadHasher});super({repo:t,codecs:r,hashers:d,preload:n=>{}}),Object.assign(this,R()),this.repo=t,this.rootCID,this.tx={pending:w.create(),getExistingTx:async()=>{let n={};try{console.log({pending:this.tx.pending});let o=this.tx.pending.last;if(!o)return;console.log({last:o});let i=await this.tx.pending.get(o);console.log({lastBlock:i}),n=i.value,console.log({existingTx:n})}catch{}return n},add:async(n,o)=>{var y;let i=!1,l=await this.tx.getExistingTx();if(l&&l[n])i=l[n].current;else if(this.rootCID)try{i=((y=(await this.get(this.rootCID)).value[n])==null?void 0:y.current)||!1}catch(m){console.log(`no prev dag ${n}`,m)}let f=await this.tx.pending.add(o),p=Object.assign({},l,{[n]:{current:f,prev:i}});console.log({newBlock:p});let g=await this.tx.pending.add(p);return this.emit("added",g),g},commit:async()=>{let n=await this.tx.getExistingTx(),o={};try{this.rootCID&&(o=(await this.get(this.rootCID)).value)}catch(f){console.log({error:f})}let i=Object.assign({},o,n);this.rootCID=await this.tx.pending.add(i);const l=await this.tx.pending.commit();return await this.importBuffer(l),this.tx.pending=w.create(),l}}}async importBuffers(t){let r;for(const a of t)r=await this.importBuffer(a);return r}async importBuffer(t){const r=await le([t]),[{root:a}]=await fe(this.import(r));return a.cid}}async function ye(e={}){const t={name:_.name,code:_.code,encode:i=>i,decode:i=>i},r=Object.values(S);[W,$,T,se,t].concat(e.ipld&&e.ipld.codecs||[]).forEach(i=>r.push(i));const a=new ce({codecs:r,loadCodec:e.ipld&&e.ipld.loadCodec}),s=e.path||"ipfs",d=J(console.log,a,{path:s,autoMigrate:!0}),n={};try{await d.init(n),await d.open()}catch(i){throw i}const o=await d.config.getAll();return new pe({repo:d,codecs:a,options:{...e,repoConfig:o}})}export{ye as c};
