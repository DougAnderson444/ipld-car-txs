import{w as g,r as m,e as S,C as f,t as H,a as $,c as R,b as x,d as v,f as D,g as J,h as E,i as y,j as B,s as P,k as U,l as _,m as I,n as F,o as L,p as M,q as W}from"./_page-9f5a62bd.js";import"./index-a6cc9c6d.js";import"./preload-helper-aa6bc0ce.js";import"./index-7ea16a28.js";const G=async e=>{for await(const t of e)return t};var T=G;const q=async e=>{let t;for await(const r of e)t=r;return t};var z=q;function V({codecs:e,repo:t,preload:r}){return g(async function(c,a={}){if(a.preload!==!1&&r(c),a.path){const l=a.localResolve?await T(m(c,a.path,e,t,a)):await z(m(c,a.path,e,t,a));if(!l)throw S(new Error("Not found"),"ERR_NOT_FOUND");return l}const h=await e.getCodec(c.code),o=await t.blocks.get(c,a);return{value:h.decode(o),remainderPath:""}})}function K({repo:e,codecs:t,hashers:r,preload:n}){async function s(c,a={}){const h=a.pin?await e.gcLock.readLock():null;try{const o=await t.getCodec(a.storeCodec||"dag-cbor");if(!o)throw new Error(`Unknown storeCodec ${a.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(a.inputCodec){if(!(c instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const C=await t.getCodec(a.inputCodec);if(!C)throw new Error(`Unknown inputCodec ${a.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);c=C.decode(c)}const w=a.version!=null?a.version:1,p=await r.getHasher(a.hashAlg||"sha2-256");if(!p)throw new Error(`Unknown hash algorithm ${a.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const l=o.encode(c),O=await p.digest(l),u=f.create(w,o.code,O);return await e.blocks.put(u,l,{signal:a.signal}),a.pin&&await e.pins.pinRecursively(u),a.preload!==!1&&n(u),u}finally{h&&h()}}return g(s)}function Q({repo:e,codecs:t,preload:r}){async function n(s,c={}){const{cid:a}=H(s);return c.preload!==!1&&r(a),$(e,t,s,c)}return g(n)}class b{constructor({repo:t,codecs:r,hashers:n,preload:s}){this.export=R({repo:t,preload:s,codecs:r}),this.get=V({codecs:r,repo:t,preload:s}),this.import=x({repo:t}),this.resolve=Q({repo:t,codecs:r,preload:s}),this.put=K({repo:t,codecs:r,hashers:n,preload:s})}}function d(e){return v.encode(e).slice(1)}function i(e){return v.decode(`u${e}`)}function X(e){const[t,r,n]=e;return{payload:r,signatures:[{protected:t,signature:n}],link:f.decode(i(r))}}function Y(e){const t={signature:i(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=i(e.protected)),t}function Z(e){const t=i(e.payload);try{f.decode(t)}catch{throw new Error("Not a valid DagJWS")}return{payload:t,signatures:e.signatures.map(Y)}}function j(e){const t={signature:d(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=d(e.protected)),t}function ee(e){const t={payload:d(e.payload),signatures:e.signatures.map(j)};return t.link=f.decode(new Uint8Array(e.payload)),t}function te(e){const[t,r,n,s,c]=e,a={ciphertext:s,iv:n,protected:t,tag:c};return r&&(a.recipients=[{encrypted_key:r}]),a}function re(e){const t={};return e.encrypted_key&&(t.encrypted_key=i(e.encrypted_key)),e.header&&(t.header=e.header),t}function ae(e){const t={ciphertext:i(e.ciphertext),protected:i(e.protected),iv:i(e.iv),tag:i(e.tag)};return e.aad&&(t.aad=i(e.aad)),e.recipients&&(t.recipients=e.recipients.map(re)),e.unprotected&&(t.unprotected=e.unprotected),t}function ne(e){const t={};return e.encrypted_key&&(t.encrypted_key=d(e.encrypted_key)),e.header&&(t.header=e.header),t}function ce(e){const t={ciphertext:d(e.ciphertext),protected:d(e.protected),iv:d(e.iv),tag:d(e.tag)};return e.aad&&(t.aad=d(e.aad)),e.recipients&&(t.recipients=e.recipients.map(ne)),e.unprotected&&(t.unprotected=e.unprotected),t}const se="dag-jose",oe=133;function k(e){return"payload"in e&&typeof e.payload=="string"&&"signatures"in e&&Array.isArray(e.signatures)}function ie(e){return"payload"in e&&e.payload instanceof Uint8Array&&"signatures"in e&&Array.isArray(e.signatures)}function de(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}function A(e){return"ciphertext"in e&&typeof e.ciphertext=="string"&&"iv"in e&&typeof e.iv=="string"&&"protected"in e&&typeof e.protected=="string"&&"tag"in e&&typeof e.tag=="string"}function N(e){if(typeof e=="string"){const t=e.split(".");if(t.length===3)return X(t);if(t.length===5)return te(t);throw new Error("Not a valid JOSE string")}if(k(e)||A(e))return e;throw new Error("Not a valid unencoded JOSE object")}function he(e){typeof e=="string"&&(e=N(e));let t;if(k(e))t=Z(e);else if(A(e))t=ae(e);else throw new Error("Not a valid JOSE object");return new Uint8Array(D(t))}function le(e){let t;try{t=J(e)}catch{throw new Error("Not a valid DAG-JOSE object")}if(ie(t))return ee(t);if(de(t))return ce(t);throw new Error("Not a valid DAG-JOSE object")}const ue=Object.freeze(Object.defineProperty({__proto__:null,name:se,code:oe,toGeneral:N,encode:he,decode:le},Symbol.toStringTag,{value:"Module"})),fe=e=>Promise.reject(new Error(`No codec found for "${e}"`));class pe{constructor(t){this._codecsByName={},this._codecsByCode={},this._loadCodec=t.loadCodec||fe;for(const r of t.codecs)this.addCodec(r)}addCodec(t){if(this._codecsByName[t.name]||this._codecsByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._codecsByName[t.name]=t,this._codecsByCode[t.code]=t}removeCodec(t){delete this._codecsByName[t.name],delete this._codecsByCode[t.code]}async getCodec(t){const r=typeof t=="string"?this._codecsByName:this._codecsByCode;if(r[t])return r[t];const n=await this._loadCodec(t);return r[t]==null&&this.addCodec(n),n}listCodecs(){return Object.values(this._codecsByName)}}const ye=e=>Promise.reject(new Error(`No hasher found for "${e}"`));class ge{constructor(t){this._hashersByName={},this._hashersByCode={},this._loadHasher=t.loadHasher||ye;for(const r of t.hashers)this.addHasher(r)}addHasher(t){if(this._hashersByName[t.name]||this._hashersByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._hashersByName[t.name]=t,this._hashersByCode[t.code]=t}removeHasher(t){delete this._hashersByName[t.name],delete this._hashersByCode[t.code]}async getHasher(t){const r=typeof t=="string"?this._hashersByName:this._hashersByCode;if(r[t])return r[t];const n=await this._loadHasher(t);return r[t]==null&&this.addHasher(n),n}listHashers(){return Object.values(this._hashersByName)}}async function we(e={}){const t=e.path||"ipfs",n=E(t,s=>{const c={[M]:y,[W]:y,[dagCbor.code]:dagCbor,[dagCbor.name]:dagCbor};return Promise.resolve(c[s])});return await n.init(),n}async function Be(){const e=await we();return new b({repo:e,codecs:[y,B],hashers:[P],preload:!1})}class Ce{constructor({repo:t,codecs:r,options:n}){const c=Object.values(U);(n.ipld&&n.ipld.hashers?n.ipld.hashers:[]).forEach(o=>c.push(o));const a=new ge({hashers:c,loadHasher:n.ipld&&n.ipld.loadHasher}),h=new b({repo:t,codecs:r,hashers:a,preload:!1});Object.assign(this,h)}}async function be(e={}){const t={name:_.name,code:_.code,encode:o=>o,decode:o=>o},r=Object.values(I);[F,B,L,ue,t].concat(e.ipld&&e.ipld.codecs||[]).forEach(o=>r.push(o));const n=new pe({codecs:r,loadCodec:e.ipld&&e.ipld.loadCodec}),s=e.path||"ipfs",c=E(console.log,n,{path:s,autoMigrate:!0}),a={};try{await c.init(a),await c.open()}catch(o){throw o}console.log({repo:c});const h=await c.config.getAll();return new Ce({repo:c,codecs:n,options:{...e,repoConfig:h}})}export{Ce as DagRepo,Be as createDag,be as createDagRepo,we as repoInit};
