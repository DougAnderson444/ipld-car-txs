import{S as $,i as H,s as J,q as C,r as _,b as v,u as D,A as E,h as B,o as R}from"./index-a6cc9c6d.js";import{T as b,w,r as S,e as P,C as g,t as U,a as T,c as I,b as L,d as N,f as F,g as M,i as A,h as W,j as G,k as q,l as X,m as z,n as V}from"./index-df62fd85.js";function K(e){let t,a;return{c(){t=C("CarTX: "),a=C(e[0])},l(r){t=_(r,"CarTX: "),a=_(r,e[0])},m(r,o){v(r,t,o),v(r,a,o)},p(r,[o]){o&1&&D(a,r[0])},i:E,o:E,d(r){r&&B(t),r&&B(a)}}}function Q(e,t,a){let r={some:"data"},o;return R(async()=>{const s=b.create(),n=await s.add(r);await s.add({sub:n});const c=await s.commit(),{root:i,get:f}=await b.load(c),{sub:y}=await f(i);if(a(0,{some:o}=await f(y),o),o!==r.some)throw new Error("data error");let d;globalThis.dag?d=globalThis.dag:(d=await xe(),globalThis.dag=d);const p=await d.importBuffer(c);console.log({cid:p});const u=await d.getLocal(p,{path:"/sub"});console.log(i.toString()==p.toString()),console.log(JSON.stringify(u.value)==JSON.stringify(r)),console.log(u.value,r)}),[o]}class Je extends ${constructor(t){super(),H(this,t,Q,K,J,{})}}async function*Y(e){let t=0;for(;t<e.length;)yield e[t++]}const Z=async e=>{for await(const t of e)return t};var j=Z;const ee=async e=>{let t;for await(const a of e)t=a;return t};var te=ee;function ae({codecs:e,repo:t,preload:a}){return w(async function(s,n={}){if(n.preload!==!1&&a(s),n.path){const d=n.localResolve?await j(S(s,n.path,e,t,n)):await te(S(s,n.path,e,t,n));if(!d)throw P(new Error("Not found"),"ERR_NOT_FOUND");return d}const c=await e.getCodec(s.code),i=await t.blocks.get(s,n);return{value:c.decode(i),remainderPath:""}})}function re({repo:e,codecs:t,hashers:a,preload:r}){async function o(s,n={}){const c=n.pin?await e.gcLock.readLock():null;try{const i=await t.getCodec(n.storeCodec||"dag-cbor");if(!i)throw new Error(`Unknown storeCodec ${n.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(n.inputCodec){if(!(s instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const m=await t.getCodec(n.inputCodec);if(!m)throw new Error(`Unknown inputCodec ${n.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);s=m.decode(s)}const f=n.version!=null?n.version:1,y=await a.getHasher(n.hashAlg||"sha2-256");if(!y)throw new Error(`Unknown hash algorithm ${n.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const d=i.encode(s),p=await y.digest(d),u=g.create(f,i.code,p);return await e.blocks.put(u,d,{signal:n.signal}),n.pin&&await e.pins.pinRecursively(u),n.preload!==!1&&r(u),u}finally{c&&c()}}return w(o)}function ne({repo:e,codecs:t,preload:a}){async function r(o,s={}){const{cid:n}=U(o);return s.preload!==!1&&a(n),T(e,t,o,s)}return w(r)}class se{constructor({repo:t,codecs:a,hashers:r,preload:o}){this.export=I({repo:t,preload:o,codecs:a}),this.get=ae({codecs:a,repo:t,preload:o}),this.import=L({repo:t}),this.resolve=ne({repo:t,codecs:a,preload:o}),this.put=re({repo:t,codecs:a,hashers:r,preload:o})}}function h(e){return N.encode(e).slice(1)}function l(e){return N.decode(`u${e}`)}function oe(e){const[t,a,r]=e;return{payload:a,signatures:[{protected:t,signature:r}],link:g.decode(l(a))}}function ie(e){const t={signature:l(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=l(e.protected)),t}function ce(e){const t=l(e.payload);try{g.decode(t)}catch{throw new Error("Not a valid DagJWS")}return{payload:t,signatures:e.signatures.map(ie)}}function de(e){const t={signature:h(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=h(e.protected)),t}function le(e){const t={payload:h(e.payload),signatures:e.signatures.map(de)};return t.link=g.decode(new Uint8Array(e.payload)),t}function he(e){const[t,a,r,o,s]=e,n={ciphertext:o,iv:r,protected:t,tag:s};return a&&(n.recipients=[{encrypted_key:a}]),n}function ue(e){const t={};return e.encrypted_key&&(t.encrypted_key=l(e.encrypted_key)),e.header&&(t.header=e.header),t}function fe(e){const t={ciphertext:l(e.ciphertext),protected:l(e.protected),iv:l(e.iv),tag:l(e.tag)};return e.aad&&(t.aad=l(e.aad)),e.recipients&&(t.recipients=e.recipients.map(ue)),e.unprotected&&(t.unprotected=e.unprotected),t}function ye(e){const t={};return e.encrypted_key&&(t.encrypted_key=h(e.encrypted_key)),e.header&&(t.header=e.header),t}function pe(e){const t={ciphertext:h(e.ciphertext),protected:h(e.protected),iv:h(e.iv),tag:h(e.tag)};return e.aad&&(t.aad=h(e.aad)),e.recipients&&(t.recipients=e.recipients.map(ye)),e.unprotected&&(t.unprotected=e.unprotected),t}const ge="dag-jose",we=133;function O(e){return"payload"in e&&typeof e.payload=="string"&&"signatures"in e&&Array.isArray(e.signatures)}function me(e){return"payload"in e&&e.payload instanceof Uint8Array&&"signatures"in e&&Array.isArray(e.signatures)}function Ce(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}function k(e){return"ciphertext"in e&&typeof e.ciphertext=="string"&&"iv"in e&&typeof e.iv=="string"&&"protected"in e&&typeof e.protected=="string"&&"tag"in e&&typeof e.tag=="string"}function x(e){if(typeof e=="string"){const t=e.split(".");if(t.length===3)return oe(t);if(t.length===5)return he(t);throw new Error("Not a valid JOSE string")}if(O(e)||k(e))return e;throw new Error("Not a valid unencoded JOSE object")}function _e(e){typeof e=="string"&&(e=x(e));let t;if(O(e))t=ce(e);else if(k(e))t=fe(e);else throw new Error("Not a valid JOSE object");return new Uint8Array(F(t))}function ve(e){let t;try{t=M(e)}catch{throw new Error("Not a valid DAG-JOSE object")}if(me(t))return le(t);if(Ce(t))return pe(t);throw new Error("Not a valid DAG-JOSE object")}const Ee=Object.freeze(Object.defineProperty({__proto__:null,name:ge,code:we,toGeneral:x,encode:_e,decode:ve},Symbol.toStringTag,{value:"Module"})),Be=e=>Promise.reject(new Error(`No codec found for "${e}"`));class be{constructor(t){this._codecsByName={},this._codecsByCode={},this._loadCodec=t.loadCodec||Be;for(const a of t.codecs)this.addCodec(a)}addCodec(t){if(this._codecsByName[t.name]||this._codecsByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._codecsByName[t.name]=t,this._codecsByCode[t.code]=t}removeCodec(t){delete this._codecsByName[t.name],delete this._codecsByCode[t.code]}async getCodec(t){const a=typeof t=="string"?this._codecsByName:this._codecsByCode;if(a[t])return a[t];const r=await this._loadCodec(t);return a[t]==null&&this.addCodec(r),r}listCodecs(){return Object.values(this._codecsByName)}}const Se=e=>Promise.reject(new Error(`No hasher found for "${e}"`));class Ae{constructor(t){this._hashersByName={},this._hashersByCode={},this._loadHasher=t.loadHasher||Se;for(const a of t.hashers)this.addHasher(a)}addHasher(t){if(this._hashersByName[t.name]||this._hashersByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._hashersByName[t.name]=t,this._hashersByCode[t.code]=t}removeHasher(t){delete this._hashersByName[t.name],delete this._hashersByCode[t.code]}async getHasher(t){const a=typeof t=="string"?this._hashersByName:this._hashersByCode;if(a[t])return a[t];const r=await this._loadHasher(t);return a[t]==null&&this.addHasher(r),r}listHashers(){return Object.values(this._hashersByName)}}const Ne=async e=>{const t=[];for await(const a of e)t.push(a);return t};var Oe=Ne;class ke extends se{constructor({repo:t,codecs:a,options:r}){const s=Object.values(V);(r.ipld&&r.ipld.hashers?r.ipld.hashers:[]).forEach(c=>s.push(c));const n=new Ae({hashers:s,loadHasher:r.ipld&&r.ipld.loadHasher});super({repo:t,codecs:a,hashers:n,preload:!1}),this.repo=t}async getLocal(t,a){return await this.get(t,Object.assign(a,{preload:!1}))}async importBuffer(t){const a=await Y([t]),[{root:r}]=await Oe(this.import(a));return r.cid}}async function xe(e={}){const t={name:A.name,code:A.code,encode:i=>i,decode:i=>i},a=Object.values(W);[G,q,X,Ee,t].concat(e.ipld&&e.ipld.codecs||[]).forEach(i=>a.push(i));const r=new be({codecs:a,loadCodec:e.ipld&&e.ipld.loadCodec}),o=e.path||"ipfs",s=z(console.log,r,{path:o,autoMigrate:!0}),n={};try{await s.init(n),await s.open()}catch(i){throw i}console.log({repo:s});const c=await s.config.getAll();return new ke({repo:s,codecs:r,options:{...e,repoConfig:c}})}export{Je as C,ke as D,xe as c,Y as m};
