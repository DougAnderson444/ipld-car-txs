import{v as x,e as E,d as N,C as y,p as O,c as k,a as D,b as C,f as H,g as A,i as _,h as S,j as T,k as $,l as J,A as I,m as L,n as R,T as w}from"./index-af5622be.js";const z="dag-pb",P=112;function U(e){x(e);const t={};return e.Links&&(t.Links=e.Links.map(r=>{const a={};return r.Hash&&(a.Hash=r.Hash.bytes),r.Name!==void 0&&(a.Name=r.Name),r.Tsize!==void 0&&(a.Tsize=r.Tsize),a})),e.Data&&(t.Data=e.Data),E(t)}function M(e){const t=N(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map(a=>{const o={};try{o.Hash=y.decode(a.Hash)}catch{}if(!o.Hash)throw new Error("Invalid Hash field found in link, expected CID");return a.Name!==void 0&&(o.Name=a.Name),a.Tsize!==void 0&&(o.Tsize=a.Tsize),o})),r}const W=Object.freeze(Object.defineProperty({__proto__:null,name:z,code:P,encode:U,decode:M,prepare:O,validate:x,createNode:k,createLink:D},Symbol.toStringTag,{value:"Module"}));function h(e){return C.encode(e).slice(1)}function c(e){return C.decode(`u${e}`)}function G(e){const[t,r,a]=e;return{payload:r,signatures:[{protected:t,signature:a}],link:y.decode(c(r))}}function F(e){const t={signature:c(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=c(e.protected)),t}function q(e){const t=c(e.payload);try{y.decode(t)}catch{throw new Error("Not a valid DagJWS")}return{payload:t,signatures:e.signatures.map(F)}}function K(e){const t={signature:h(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=h(e.protected)),t}function Q(e){const t={payload:h(e.payload),signatures:e.signatures.map(K)};return t.link=y.decode(new Uint8Array(e.payload)),t}function V(e){const[t,r,a,o,d]=e,i={ciphertext:o,iv:a,protected:t,tag:d};return r&&(i.recipients=[{encrypted_key:r}]),i}function X(e){const t={};return e.encrypted_key&&(t.encrypted_key=c(e.encrypted_key)),e.header&&(t.header=e.header),t}function Y(e){const t={ciphertext:c(e.ciphertext),protected:c(e.protected),iv:c(e.iv),tag:c(e.tag)};return e.aad&&(t.aad=c(e.aad)),e.recipients&&(t.recipients=e.recipients.map(X)),e.unprotected&&(t.unprotected=e.unprotected),t}function Z(e){const t={};return e.encrypted_key&&(t.encrypted_key=h(e.encrypted_key)),e.header&&(t.header=e.header),t}function j(e){const t={ciphertext:h(e.ciphertext),protected:h(e.protected),iv:h(e.iv),tag:h(e.tag)};return e.aad&&(t.aad=h(e.aad)),e.recipients&&(t.recipients=e.recipients.map(Z)),e.unprotected&&(t.unprotected=e.unprotected),t}const ee="dag-jose",te=133;function B(e){return"payload"in e&&typeof e.payload=="string"&&"signatures"in e&&Array.isArray(e.signatures)}function re(e){return"payload"in e&&e.payload instanceof Uint8Array&&"signatures"in e&&Array.isArray(e.signatures)}function ae(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}function v(e){return"ciphertext"in e&&typeof e.ciphertext=="string"&&"iv"in e&&typeof e.iv=="string"&&"protected"in e&&typeof e.protected=="string"&&"tag"in e&&typeof e.tag=="string"}function b(e){if(typeof e=="string"){const t=e.split(".");if(t.length===3)return G(t);if(t.length===5)return V(t);throw new Error("Not a valid JOSE string")}if(B(e)||v(e))return e;throw new Error("Not a valid unencoded JOSE object")}function ie(e){typeof e=="string"&&(e=b(e));let t;if(B(e))t=q(e);else if(v(e))t=Y(e);else throw new Error("Not a valid JOSE object");return new Uint8Array(H(t))}function ne(e){let t;try{t=A(e)}catch{throw new Error("Not a valid DAG-JOSE object")}if(re(t))return Q(t);if(ae(t))return j(t);throw new Error("Not a valid DAG-JOSE object")}const se=Object.freeze(Object.defineProperty({__proto__:null,name:ee,code:te,toGeneral:b,encode:ie,decode:ne},Symbol.toStringTag,{value:"Module"})),oe=e=>Promise.reject(new Error(`No codec found for "${e}"`));class ce{constructor(t){this._codecsByName={},this._codecsByCode={},this._loadCodec=t.loadCodec||oe;for(const r of t.codecs)this.addCodec(r)}addCodec(t){if(this._codecsByName[t.name]||this._codecsByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._codecsByName[t.name]=t,this._codecsByCode[t.code]=t}removeCodec(t){delete this._codecsByName[t.name],delete this._codecsByCode[t.code]}async getCodec(t){const r=typeof t=="string"?this._codecsByName:this._codecsByCode;if(r[t])return r[t];const a=await this._loadCodec(t);return r[t]==null&&this.addCodec(a),a}listCodecs(){return Object.values(this._codecsByName)}}const de=e=>Promise.reject(new Error(`No hasher found for "${e}"`));class he{constructor(t){this._hashersByName={},this._hashersByCode={},this._loadHasher=t.loadHasher||de;for(const r of t.hashers)this.addHasher(r)}addHasher(t){if(this._hashersByName[t.name]||this._hashersByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._hashersByName[t.name]=t,this._hashersByCode[t.code]=t}removeHasher(t){delete this._hashersByName[t.name],delete this._hashersByCode[t.code]}async getHasher(t){const r=typeof t=="string"?this._hashersByName:this._hashersByCode;if(r[t])return r[t];const a=await this._loadHasher(t);return r[t]==null&&this.addHasher(a),a}listHashers(){return Object.values(this._hashersByName)}}async function*fe(e){let t=0;for(;t<e.length;)yield e[t++]}const le=async e=>{const t=[];for await(const r of e)t.push(r);return t};var ue=le;class pe extends I{constructor({repo:t,codecs:r,options:a}){const o=Object.values(L);(a.ipld&&a.ipld.hashers?a.ipld.hashers:[]).forEach(i=>o.push(i));const d=new he({hashers:o,loadHasher:a.ipld&&a.ipld.loadHasher});super({repo:t,codecs:r,hashers:d,preload:i=>{}}),Object.assign(this,R()),this.repo=t,this.rootCID,this.tx={pending:w.create(),getExistingTx:async()=>{let i={};try{let s=this.tx.pending.last;if(!s)return;i=(await this.tx.pending.get(s)).value}catch{}return i},add:async(i,s)=>{if(!s)return;s=Object.fromEntries(Object.entries(s).map(([l,m])=>m===void 0?[l,null]:[l,m]));let n=!1,f=await this.tx.getExistingTx();if(f&&f[i])n=f[i]?f[i]:!1;else if(this.rootCID)try{let l=(await this.get(this.rootCID)).value;n=l[i]?l[i]:!1}catch{}let u=await this.tx.pending.add(s),p=Object.assign({},f,{[i]:{obj:u,prev:n}}),g=await this.tx.pending.add(p);return this.emit("added",g),g},commit:async()=>{let i=await this.tx.getExistingTx(),s={};try{this.rootCID&&(s=(await this.get(this.rootCID)).value)}catch(u){console.log({error:u})}let n=Object.assign({},s,Object.fromEntries(Object.entries(i).filter(([u,p])=>p.obj&&p.hasOwnProperty("prev"))));this.rootCID=await this.tx.pending.add(n);const f=await this.tx.pending.commit();return await this.importBuffer(f),this.tx.pending=w.create(),f}}}async importBuffers(t){let r;for(const a of t)r=await this.importBuffer(a);return r}async importBuffer(t){return ye(this,t)}}async function ye(e,t){const r=await fe([t]),[{root:a}]=await ue(e.import(r));return a.cid}async function me(e={}){const t={name:_.name,code:_.code,encode:n=>n,decode:n=>n},r=Object.values(S);[W,T,$,se,t].concat(e.ipld&&e.ipld.codecs||[]).forEach(n=>r.push(n));const a=new ce({codecs:r,loadCodec:e.ipld&&e.ipld.loadCodec}),o=e.path||"ipfs",d=J(console.log,a,{path:o,autoMigrate:!0}),i={};try{await d.init(i),await d.open()}catch(n){throw n}const s=await d.config.getAll();return new pe({repo:d,codecs:a,options:{...e,repoConfig:s}})}export{me as c,ye as i};
