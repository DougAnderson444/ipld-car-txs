import{C as Le}from"./CarTxs-9d9479bd.js";import{S as $,i as S,s as N,k as O,v as x,l as b,m as H,w as R,h as w,n as D,b as J,x as P,A as U,f as I,t as T,y as F}from"./index-332b1762.js";import{A as L}from"./_page-6dbcbd9e.js";import{w as y,r as _,e as M,C as f,t as W,a as G,c as V,b as z,d as v,f as q,g as K,h as Q,i as C,j as X,k as Y,l as Z,m as j,n as ee}from"./index-e747751a.js";import{T as We,T as Ge}from"./index-e747751a.js";import"./preload-helper-aa6bc0ce.js";import"./index-b842831c.js";function te(e){let t,r,n;return r=new L({}),{c(){t=O("div"),x(r.$$.fragment),this.h()},l(i){t=b(i,"DIV",{class:!0});var s=H(t);R(r.$$.fragment,s),s.forEach(w),this.h()},h(){D(t,"class","")},m(i,s){J(i,t,s),P(r,t,null),n=!0},p:U,i(i){n||(I(r.$$.fragment,i),n=!0)},o(i){T(r.$$.fragment,i),n=!1},d(i){i&&w(t),F(r)}}}class Ue extends ${constructor(t){super(),S(this,t,null,te,N,{})}}const re=async e=>{for await(const t of e)return t};var ae=re;const ne=async e=>{let t;for await(const r of e)t=r;return t};var se=ne;function ie({codecs:e,repo:t,preload:r}){return y(async function(s,a={}){if(a.preload!==!1&&r(s),a.path){const l=a.localResolve?await ae(_(s,a.path,e,t,a)):await se(_(s,a.path,e,t,a));if(!l)throw M(new Error("Not found"),"ERR_NOT_FOUND");return l}const h=await e.getCodec(s.code),c=await t.blocks.get(s,a);return{value:h.decode(c),remainderPath:""}})}function ce({repo:e,codecs:t,hashers:r,preload:n}){async function i(s,a={}){const h=a.pin?await e.gcLock.readLock():null;try{const c=await t.getCodec(a.storeCodec||"dag-cbor");if(!c)throw new Error(`Unknown storeCodec ${a.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(a.inputCodec){if(!(s instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const m=await t.getCodec(a.inputCodec);if(!m)throw new Error(`Unknown inputCodec ${a.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);s=m.decode(s)}const g=a.version!=null?a.version:1,p=await r.getHasher(a.hashAlg||"sha2-256");if(!p)throw new Error(`Unknown hash algorithm ${a.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const l=c.encode(s),k=await p.digest(l),u=f.create(g,c.code,k);return await e.blocks.put(u,l,{signal:a.signal}),a.pin&&await e.pins.pinRecursively(u),a.preload!==!1&&n(u),u}finally{h&&h()}}return y(i)}function oe({repo:e,codecs:t,preload:r}){async function n(i,s={}){const{cid:a}=W(i);return s.preload!==!1&&r(a),G(e,t,i,s)}return y(n)}class de{constructor({repo:t,codecs:r,hashers:n,preload:i}){this.export=V({repo:t,preload:i,codecs:r}),this.get=ie({codecs:r,repo:t,preload:i}),this.import=z({repo:t}),this.resolve=oe({repo:t,codecs:r,preload:i}),this.put=ce({repo:t,codecs:r,hashers:n,preload:i})}}function d(e){return v.encode(e).slice(1)}function o(e){return v.decode(`u${e}`)}function he(e){const[t,r,n]=e;return{payload:r,signatures:[{protected:t,signature:n}],link:f.decode(o(r))}}function le(e){const t={signature:o(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=o(e.protected)),t}function ue(e){const t=o(e.payload);try{f.decode(t)}catch{throw new Error("Not a valid DagJWS")}return{payload:t,signatures:e.signatures.map(le)}}function fe(e){const t={signature:d(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=d(e.protected)),t}function pe(e){const t={payload:d(e.payload),signatures:e.signatures.map(fe)};return t.link=f.decode(new Uint8Array(e.payload)),t}function ye(e){const[t,r,n,i,s]=e,a={ciphertext:i,iv:n,protected:t,tag:s};return r&&(a.recipients=[{encrypted_key:r}]),a}function ge(e){const t={};return e.encrypted_key&&(t.encrypted_key=o(e.encrypted_key)),e.header&&(t.header=e.header),t}function me(e){const t={ciphertext:o(e.ciphertext),protected:o(e.protected),iv:o(e.iv),tag:o(e.tag)};return e.aad&&(t.aad=o(e.aad)),e.recipients&&(t.recipients=e.recipients.map(ge)),e.unprotected&&(t.unprotected=e.unprotected),t}function we(e){const t={};return e.encrypted_key&&(t.encrypted_key=d(e.encrypted_key)),e.header&&(t.header=e.header),t}function _e(e){const t={ciphertext:d(e.ciphertext),protected:d(e.protected),iv:d(e.iv),tag:d(e.tag)};return e.aad&&(t.aad=d(e.aad)),e.recipients&&(t.recipients=e.recipients.map(we)),e.unprotected&&(t.unprotected=e.unprotected),t}const Ce="dag-jose",ve=133;function E(e){return"payload"in e&&typeof e.payload=="string"&&"signatures"in e&&Array.isArray(e.signatures)}function Ee(e){return"payload"in e&&e.payload instanceof Uint8Array&&"signatures"in e&&Array.isArray(e.signatures)}function Be(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}function B(e){return"ciphertext"in e&&typeof e.ciphertext=="string"&&"iv"in e&&typeof e.iv=="string"&&"protected"in e&&typeof e.protected=="string"&&"tag"in e&&typeof e.tag=="string"}function A(e){if(typeof e=="string"){const t=e.split(".");if(t.length===3)return he(t);if(t.length===5)return ye(t);throw new Error("Not a valid JOSE string")}if(E(e)||B(e))return e;throw new Error("Not a valid unencoded JOSE object")}function Ae(e){typeof e=="string"&&(e=A(e));let t;if(E(e))t=ue(e);else if(B(e))t=me(e);else throw new Error("Not a valid JOSE object");return new Uint8Array(q(t))}function ke(e){let t;try{t=K(e)}catch{throw new Error("Not a valid DAG-JOSE object")}if(Ee(t))return pe(t);if(Be(t))return _e(t);throw new Error("Not a valid DAG-JOSE object")}const $e=Object.freeze(Object.defineProperty({__proto__:null,name:Ce,code:ve,toGeneral:A,encode:Ae,decode:ke},Symbol.toStringTag,{value:"Module"})),Se=e=>Promise.reject(new Error(`No codec found for "${e}"`));class Ne{constructor(t){this._codecsByName={},this._codecsByCode={},this._loadCodec=t.loadCodec||Se;for(const r of t.codecs)this.addCodec(r)}addCodec(t){if(this._codecsByName[t.name]||this._codecsByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._codecsByName[t.name]=t,this._codecsByCode[t.code]=t}removeCodec(t){delete this._codecsByName[t.name],delete this._codecsByCode[t.code]}async getCodec(t){const r=typeof t=="string"?this._codecsByName:this._codecsByCode;if(r[t])return r[t];const n=await this._loadCodec(t);return r[t]==null&&this.addCodec(n),n}listCodecs(){return Object.values(this._codecsByName)}}const Oe=e=>Promise.reject(new Error(`No hasher found for "${e}"`));class xe{constructor(t){this._hashersByName={},this._hashersByCode={},this._loadHasher=t.loadHasher||Oe;for(const r of t.hashers)this.addHasher(r)}addHasher(t){if(this._hashersByName[t.name]||this._hashersByCode[t.code])throw new Error(`Resolver already exists for codec "${t.name}"`);this._hashersByName[t.name]=t,this._hashersByCode[t.code]=t}removeHasher(t){delete this._hashersByName[t.name],delete this._hashersByCode[t.code]}async getHasher(t){const r=typeof t=="string"?this._hashersByName:this._hashersByCode;if(r[t])return r[t];const n=await this._loadHasher(t);return r[t]==null&&this.addHasher(n),n}listHashers(){return Object.values(this._hashersByName)}}class be{constructor({repo:t,codecs:r,options:n}){const s=Object.values(Q);(n.ipld&&n.ipld.hashers?n.ipld.hashers:[]).forEach(c=>s.push(c));const a=new xe({hashers:s,loadHasher:n.ipld&&n.ipld.loadHasher}),h=new de({repo:t,codecs:r,hashers:a,preload:!1});Object.assign(this,h)}}async function Ie(e={}){const t={name:C.name,code:C.code,encode:c=>c,decode:c=>c},r=Object.values(X);[Y,Z,j,$e,t].concat(e.ipld&&e.ipld.codecs||[]).forEach(c=>r.push(c));const n=new Ne({codecs:r,loadCodec:e.ipld&&e.ipld.loadCodec}),i=e.path||"ipfs",s=ee(console.log,n,{path:i,autoMigrate:!0}),a={};try{await s.init(a),await s.open()}catch(c){throw c}console.log({repo:s});const h=await s.config.getAll();return new be({repo:s,codecs:n,options:{...e,repoConfig:h}})}export{Le as CarTxs,be as DagRepo,We as Transaction,Ue as Viz,Ie as createDagRepo,Ge as default};
